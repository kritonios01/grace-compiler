Notes for Kriton

  Πρώτα απ' όλα, το 'frontend' του μεταγλωττιστή χωρίζεται σε 3 μέρη: την λεκτική ανάλυση (Lexer.mll), την συντακτική (Parser.mly και Ast.ml) και την σημασιολογική. Η λεκτική ανάλυση φροντίζει να μετατρέψει μια σειρά από χαρακτήρες σε μια ακολουθία από tokens. Η συντακτική ανάλυση έχει σκοπό να δημιουργήσει ένα αφηρημένο συντακτικό δέντρο (AST) από την ακολουθία tokens που παράγεται από την λεκτική ανάλυση (λέγεται αφηρημένο επειδή ο κάθε κόμβος του δένδρου είναι τύπου ορισμένου από εμάς). Τέλος, η σημασιολογική ανάλυση ελέγχει για σημασιολογικά λάθη του AST, όπως type mismatch, segmentation faults, undefined variables, κ.ά. Τελικά, η πορεία του προγράμματος κατευθύνεται από τον Lexer -> Parser -> ( Ast -> ) Semantic-analyser.

  Στο αρχείο Parser.mly γράφεται κώδικας που συνδυάζει τα tokens του Lexer και τους κόμβους του Ast. Ας αποδομήσουμε, λοιπόν, την δομή του αρχείου αυτού.

  Το Parser.mly αρχείο χωρίζεται σε τρία μέρη της εξής μορής:

%{
  <Μέρος-Α>
%}

<Μέρος-Β>

%%

<Μέρος-Γ>

Το Μέρος-Α είναι αυτό στο οποίο θα γίνει η χρήση κάποιας βιβλιοθήκης (εντολές "open Lib"), ο ορισμός συναρτήσεων κ.ο.κ.

Το Μέρος-Β χωρίζεται σε 3 υπο-κατηγορίες (οι οποίες δεν αναφέρονται σε κάποιο manual page, αλλά βοηθά στην αντίληψη του κώδικα):

-> Token declarations:
	Τα tokens που χρησιμοποιεί ο Lexer δηλώνονται στο αρχείο Parser.mly. Υπενθυμίζεται ότι τα tokens αυτά θα χρησιμοποιηθούν από τον Parser για την δημιουργία του AST (επομένως είναι λογικό να δηλώνονται εδώ και όχι στο αρχείο Lexer.mll). Η κάθε γραμμή του κώδικα στο κομμάτι αυτό έχει τις εξής δύο μορφές:
%token T_name_of_token
%token <type_of_token> T_name_of_token
Στην 1η περίπτωση, το token δεν φέρει κάποια τιμή, ενώ στην 2η φέρει μία τιμή τύπου type_of_token. Για παράδειγμα, το σύμβολο '(' ταιριάζει στην 1η περίπτωση, ενώ το token T_identifier που χρησιμοποιείται για αναγνωριστικά μεταβλητών μπορεί να φέρει μία μεταβλητή τύπου string.

-> Operator tokens' hierarchy:
	Τα tokens τελεστών όπως πχ T_plus, T_minus, T_mod κλπ πρέπει να ενταχθούν σε μία ιεραρχία προτεραιότητας, ώστε πχ ο πολλαπλασιασμός να έχει μεγαλύτερη προτεραιότητα από την πρόσθεση. Οι γραμμές του κώδικα έχουν την μορφή "%{left,right,nonassoc} T_token1, T_token2". Οι τελεστές με μεγαλύτερη προτεραιότητα γράφονται πιο κάτω, αυτοί με μικρότερη γράφονται πιο πάνω και αυτοί με ίση (πχ πρόσθεση και αφαίρεση) γράφονται στην ίδια γραμμή.

-> Types of non-terminal symbols
	Η γραμματική της γλώσσας μας έχει ένα σύνολο από μη-τερματικά σύμβολα και κάποιους κανόνες παραγωγής για κάθε ένα από αυτά. Το κάθε ένα από αυτά τα σύμβολα αντιστοιχεί σε έναν κόμβο του AST. Η πρώτη γραμμή του μέρους αυτού έχει την μορφή "%start non-terminal-symbol" και ορίζει το αρχικό μη-τερματικό σύμβολο της γραμματικής. Έπειτα η κάθε γραμμή έχει την μορφή "%type <type-defined-in-Ast.ml> non-terminal-symbol". Έτσι, το κάθε μη-τερματικό σύμβολο θα αντιστοιχεί σε έναν τύπο κόμβου του AST.


Τέλος, το Μέρος-Γ είναι το σημείο στο οποίο γράφουμε την γραμματική της γλώσσας μας. Ο κάθε κανόνας έχει την εξής μορφή (παράδειγμα):

non-term-symb-1: T_token1 T_token2 non-term-symb-2 T_token3 { ocaml-command }

Η εντολή που περιέχεται μεταξύ των αγκυλών '{' '}' επιστέφει μία έκφραση του αντίστοιχου τύπου του non-term-symb-1 (αυτού που ορίζεται στην 3η υποκατηγορία του Μέρους-Β). Για παράδειγμα αν το non-term-symb-2 φέρει μία τιμή τύπου int και το non-term-symb-1 αντιστοιχεί σε έναν κόμβο με τύπο Expression(e : int), τότε η ocaml-command θα είναι η "Expression($3)" (το σύμβολο '$' χρησιμοποιείται για να ληφθεί η τιμή που φέρει το τρίτο token).


  Ας αναφερθούμε τώρα στο αρχείο Ast.ml. Αρχικά, παρατηρούμε ότι το αρχείο αυτό είναι αρχείο .ml, επομένως θα είναι το πρώτο αρχείο στο οποίο θα γράψουμε κανονική OCaml. Το περιεχόμενό του θα αποτελείται από εντολές "type something = ..." όπου θα δηλώνονται variant types ή record types κόμβοι του AST, ή/και άλλες εντολές που θα ορίζουμε συναρτήσεις (κυρίως κατασκευαστές των τύπων που ορίζουμε και προαιρετικά άλλες για κάποια ανάλυση του περιεχομένου των κόμβων). Για παράδειγμα, μπορούμε να ορίσουμε έναν τύπο για τους τελεστές αριθμητικών πράξεων:

type mathOperator = Operator_plus | Operator_minus | Operator_mod

Άλλο παράδειγμα είναι ο ορισμός των σταθερών τιμών:

type const_val = Constant_int of int | Constant_char of char

Άλλο παράδειγμα είναι ο ορισμός των αριθμητικών πράξεων:

type arithm_expression = Arithmetic_expr of (const_val * mathOperator * const_val)


  Εν τέλει, συμπληρώνοντας τα παραπάνω μέρη με τον κώδικά μας, καταφέρνουμε να κατασκευάσουμε το AST. Βέβαια, είναι πολύ χρήσιμο να γράψουμε και αντίστοιχες συναρτήσεις σε κάποιο αρχείο για να μπορούμε να εκτυπώσουμε το AST και να το ελέγξουμε. Αυτό θα το κάνουμε σε ένα αρχείο Main.ml.
( Spoiler-Alert: στο αρχείο αυτό μπορούμε στην συνέχεια να καλέσουμε και συναρτήσεις για την σημασιολογική ανάλυση του AST! )
